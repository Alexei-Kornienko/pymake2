#! /usr/bin/env python3
# PYTHON_ARGCOMPLETE_OK
import time

__author__ = 'Saud Wasly'

Debug = False
HighlightErrors = False
HighlightWarnings = False
# Debug = True

import argparse
import re

from pymake2 import parser as make_parser

try:
    pass
    import argcomplete
except ImportError:
    print('Warning: Autocomplete is not working\nYou need to install argcomplete package')

import os
import sys
import traceback

try:
    import utility as util
    import make
    from makefile_template import gccTemplate
except:
    from pymake2 import utility as util
    from pymake2 import make
    from pymake2.makefile_template import gccTemplate

fd_out = None  # used to bash auto complete only


class argsT():
    t = 'all'
    f = None
    j = 1


def getTargets_forBash_autocomplete(makefile_path=''):
    Targets = []
    if makefile_path == '':
        makefile_path = './makefile.py'
    if os.path.isfile(makefile_path):
        f = open(makefile_path, 'rb')
        makefile_str = f.read()
        f.close()
        makefile_lines = makefile_str.splitlines()
        for i, l in enumerate(makefile_lines):
            if l.startswith('@target'):
                resV = re.findall(r'def\s+(\w+)\s*\(', makefile_lines[i + 1])
                Targets.append(resV[0])
    return Targets


def Auto_Target():
    if os.path.isfile('./makefile.py'):
        return True
    else:
        return False


def complete_targets(prefix, parsed_args, **kwargs):
    Targets = []
    # argcomplete.warn(parsed_args)
    # argcomplete.warn(parsed_args.f)
    if parsed_args.f:
        Targets = getTargets_forBash_autocomplete(parsed_args.f)
    elif Auto_Target():
        Targets = getTargets_forBash_autocomplete('./makefile.py')
    else:
        Targets = ["No_MakeFile"]

    return Targets
    # return ['ali', 'saud', 'xxx']


def print_cmd2():
    argcomplete.warn('print_cmd2:')
    argcomplete.warn('_ARGCOMPLETE: ', os.environ['_ARGCOMPLETE'])
    argcomplete.warn('_ARGCOMPLETE_IFS: ', os.environ['_ARGCOMPLETE_IFS'])
    argcomplete.warn('COMP_LINE: ', os.environ['COMP_LINE'])
    argcomplete.warn('COMP_POINT: ', os.environ['COMP_POINT'])
    argcomplete.warn('_ARGCOMPLETE_COMP_WORDBREAKS: ', os.environ['_ARGCOMPLETE_COMP_WORDBREAKS'])
    argcomplete.warn('COMP_WORDBREAKS: ', os.environ['COMP_WORDBREAKS'])


def print2cmd(txt):
    fd_out.write(txt)


def print_cmd():
    fout = os.fdopen(8, "wb")

    def printl(l1, l2=''):
        fout.write('%s,%s\n\n' % (l1, l2))

    try:
        printl('Envirnoment')
        # printl('_ARGCOMPLETE: ', os.environ['_ARGCOMPLETE'])
        # printl('_ARGCOMPLETE_IFS: ', os.environ['_ARGCOMPLETE_IFS'])
        # printl('COMP_LINE: ', os.environ['COMP_LINE'])
        # printl('COMP_POINT: ', os.environ['COMP_POINT'])
        # printl('_ARGCOMPLETE_COMP_WORDBREAKS: ', os.environ['_ARGCOMPLETE_COMP_WORDBREAKS'])
        # printl('COMP_WORDBREAKS: ', os.environ['COMP_WORDBREAKS'])
    except:
        pass

    fout.close()


def main():
    global Debug, HighlightErrors, HighlightWarnings
    parser = argparse.ArgumentParser(description='pymake2 is a simple make system implemented in python')
    parser.add_argument('-f', metavar='MakefilePath', help='to pass a makefile, default = ./makefile.py')
    parser.add_argument('-j', metavar='Jobs', type=int, help='number of jobs used in the make process')
    parser.add_argument(
        't',
        metavar='Target',
        nargs='+',
        help='the make target in the makefile'
    ).completer = complete_targets

    argcomplete.autocomplete(parser)
    if len(sys.argv) > 1:
        args = parser.parse_args()
    else:
        args = argsT()

    if args.f:
        MakefilePath = args.f
    elif Auto_Target():
        MakefilePath = './makefile.py'
    else:
        retV = input('No makefile exists!, do you want to creat one?(y/n): ')
        if retV.lower() == 'y':
            F = open('makefile.py', 'w')
            F.write(gccTemplate)
            F.close()
        sys.exit()

    mfile = make_parser.parse(MakefilePath)

    if not args.t:
        print('No target to build, exiting...')
        sys.exit(1)
    for target in args.t:
        try:
            mfile.targets[target].build()
        except KeyError:
            util.print_color('Error: target "%s" does not exist!' % args.t, util.tty_colors_cmds.BRed)
            sys.exit(1)


if __name__ == '__main__':
    main()
