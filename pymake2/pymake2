#! /usr/bin/env python3
# PYTHON_ARGCOMPLETE_OK
import time

__author__ = 'Saud Wasly'

Debug = False
HighlightErrors = False
HighlightWarnings = False
# Debug = True

import argparse
import re

from pymake2 import parser as make_parser

try:
    pass
    import argcomplete
except ImportError:
    print('Warning: Autocomplete is not working\nYou need to install argcomplete package')

import os
import sys
import traceback

try:
    import utility as util
    import make
    from makefile_template import gccTemplate
except:
    from pymake2 import utility as util
    from pymake2 import make
    from pymake2.makefile_template import gccTemplate

fd_out = None  # used to bash auto complete only


class argsT():
    t = 'all'
    f = None
    j = 1


class Target_t(object):
    def __init__(self, func, args, MakefileM):
        self.Name = func
        self.func = getattr(MakefileM, func)
        args_str = [item.strip() for item in args.split(',')]
        args_var = [getattr(MakefileM, item) for item in args_str if item != '']
        self.args_str = args_str
        self.args_var = args_var
        self.result = None
        self.MakefileM = MakefileM
        self.Dependencies = args_var

    def is_up_to_date(self):
        target_stamp = self.timestamp()
        if self.Dependencies:
            deps_stamp = self.check_dependencies()
        else:
            deps_stamp = None
        if not target_stamp:
            return False
        if deps_stamp:
            return target_stamp > deps_stamp
        return True

    def timestamp(self):
        return os.path.getmtime(self.Name) if os.path.isfile(self.Name) else None

    def check_dependencies(self):
        stamps = []

        util.print_color('Dependency checking of Target "%s"' % self.Name, util.tty_colors_cmds.On_Cyan)
        for item in self.Dependencies:
            if type(item) is list:
                for subitem in item:  # assumed to be list of file names (paths)
                    if os.path.isfile(subitem):
                        stamps.append(os.path.getmtime(subitem))
                    else:
                        util.write_color('Dependency Error @ Target "%s": ' % self.Name, util.tty_colors_cmds.BRed)
                        raise ValueError('%s does not exsist!' % subitem)
            elif type(item) is str:
                if os.path.isfile(item):
                    stamps.append(os.path.getmtime(item))
                else:
                    util.write_color('Dependency Error @ Target "%s": ' % self.Name, util.tty_colors_cmds.BRed)
                    raise ValueError('%s does not exsist!' % item)
            elif type(item) is Target_t:  # another target
                stamps.append(item.run())

        return max(stamps) if stamps else None

    def run(self):
        try:
            if len(self.args_var) == 0:
                self.result = self.func()
            else:
                self.result = self.func(*self.args_var)
            return self.timestamp()
        except Exception as e:
            util.print_color('Target "%s" failed' % self.Name, util.tty_colors_cmds.BRed)
            raise e



def getTargets_forBash_autocomplete(makefile_path=''):
    Targets = []
    if makefile_path == '':
        makefile_path = './makefile.py'
    if os.path.isfile(makefile_path):
        f = open(makefile_path, 'rb')
        makefile_str = f.read()
        f.close()
        makefile_lines = makefile_str.splitlines()
        for i, l in enumerate(makefile_lines):
            if l.startswith('@target'):
                resV = re.findall(r'def\s+(\w+)\s*\(', makefile_lines[i + 1])
                Targets.append(resV[0])
    return Targets


def Auto_Target():
    if os.path.isfile('./makefile.py'):
        return True
    else:
        return False


def complete_targets(prefix, parsed_args, **kwargs):
    Targets = []
    # argcomplete.warn(parsed_args)
    # argcomplete.warn(parsed_args.f)
    if parsed_args.f:
        Targets = getTargets_forBash_autocomplete(parsed_args.f)
    elif Auto_Target():
        Targets = getTargets_forBash_autocomplete('./makefile.py')
    else:
        Targets = ["No_MakeFile"]

    return Targets
    # return ['ali', 'saud', 'xxx']


def print_cmd2():
    argcomplete.warn('print_cmd2:')
    argcomplete.warn('_ARGCOMPLETE: ', os.environ['_ARGCOMPLETE'])
    argcomplete.warn('_ARGCOMPLETE_IFS: ', os.environ['_ARGCOMPLETE_IFS'])
    argcomplete.warn('COMP_LINE: ', os.environ['COMP_LINE'])
    argcomplete.warn('COMP_POINT: ', os.environ['COMP_POINT'])
    argcomplete.warn('_ARGCOMPLETE_COMP_WORDBREAKS: ', os.environ['_ARGCOMPLETE_COMP_WORDBREAKS'])
    argcomplete.warn('COMP_WORDBREAKS: ', os.environ['COMP_WORDBREAKS'])


def print2cmd(txt):
    fd_out.write(txt)


def print_cmd():
    fout = os.fdopen(8, "wb")

    def printl(l1, l2=''):
        fout.write('%s,%s\n\n' % (l1, l2))

    try:
        printl('Envirnoment')
        # printl('_ARGCOMPLETE: ', os.environ['_ARGCOMPLETE'])
        # printl('_ARGCOMPLETE_IFS: ', os.environ['_ARGCOMPLETE_IFS'])
        # printl('COMP_LINE: ', os.environ['COMP_LINE'])
        # printl('COMP_POINT: ', os.environ['COMP_POINT'])
        # printl('_ARGCOMPLETE_COMP_WORDBREAKS: ', os.environ['_ARGCOMPLETE_COMP_WORDBREAKS'])
        # printl('COMP_WORDBREAKS: ', os.environ['COMP_WORDBREAKS'])
    except:
        pass

    fout.close()


def main():
    global Debug, HighlightErrors, HighlightWarnings
    parser = argparse.ArgumentParser(description='pymake2 is a simple make system implemented in python')
    parser.add_argument('-f', metavar='MakefilePath', help='to pass a makefile, default = ./makefile.py')
    parser.add_argument('-j', metavar='Jobs', type=int, help='number of jobs used in the make process')
    parser.add_argument(
        't',
        metavar='Target',
        nargs='+',
        help='the make target in the makefile'
    ).completer = complete_targets

    argcomplete.autocomplete(parser)
    if len(sys.argv) > 1:
        args = parser.parse_args()
    else:
        args = argsT()

    if args.f:
        MakefilePath = args.f
    elif Auto_Target():
        MakefilePath = './makefile.py'
    else:
        retV = input('No makefile exists!, do you want to creat one?(y/n): ')
        if retV.lower() == 'y':
            F = open('makefile.py', 'w')
            F.write(gccTemplate)
            F.close()
        sys.exit()

    mfile = make_parser.parse(MakefilePath)

    if not args.t:
        print('No target to build, exiting...')
        sys.exit(1)
    for target in args.t:
        try:
            mfile.targets[target].build()
        except KeyError:
            util.print_color('Error: target "%s" does not exist!' % args.t, util.tty_colors_cmds.BRed)
            sys.exit(1)


if __name__ == '__main__':
    main()
